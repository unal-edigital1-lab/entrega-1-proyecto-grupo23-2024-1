library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity bme280_spi is
    port (
        clk        : in  std_logic;
        reset      : in  std_logic;
        cs         : out std_logic;
        sck        : out std_logic;
        mosi       : out std_logic;
        miso       : in  std_logic;
        data_out   : out std_logic_vector(7 downto 0);  -- Datos leídos del sensor
        data_in    : in  std_logic_vector(7 downto 0);  -- Datos a escribir en el sensor
        read_en    : in  std_logic;  -- Señal para habilitar lectura
        write_en   : in  std_logic   -- Señal para habilitar escritura
    );
end entity;

architecture Behavioral of bme280_spi is
    type state_type is (idle, select, send_address, read_data, write_data, deselect);
    signal state : state_type := idle;
    signal bit_counter : integer range 0 to 7 := 0;
    signal temp_data_out : std_logic_vector(7 downto 0);
    signal temp_data_in : std_logic_vector(7 downto 0);
    signal address : std_logic_vector(7 downto 0);

begin
    process(clk, reset)
    begin
        if reset = '1' then
            state <= idle;
            cs <= '1';
            sck <= '0';
            mosi <= '0';
            data_out <= (others => '0');
            temp_data_out <= (others => '0');
        elsif rising_edge(clk) then
            case state is
                when idle =>
                    cs <= '1';  -- Deselect sensor
                    sck <= '0';
                    if read_en = '1' then
                        state <= select;
                        address <= "11110011";  -- Dirección del registro `status` (0xF3) para leer
                    elsif write_en = '1' then
                        state <= select;
                        address <= "11110010";  -- Dirección del registro `ctrl_hum` (0xF2) para escribir
                    end if;

                when select =>
                    cs <= '0';  -- Select sensor
                    state <= send_address;
                    bit_counter <= 7;
                    temp_data_out <= address;

                when send_address =>
                    sck <= not sck;
                    if sck = '1' then
                        mosi <= temp_data_out(bit_counter);
                        bit_counter <= bit_counter - 1;
                        if bit_counter < 0 then
                            if read_en = '1' then
                                state <= read_data;
                                bit_counter <= 7;
                            elsif write_en = '1' then
                                state <= write_data;
                                bit_counter <= 7;
                                temp_data_out <= data_in;  -- Cargar datos para escribir
                            end if;
                        end if;
                    end if;

                when read_data =>
                    sck <= not sck;
                    if sck = '0' then
                        temp_data_in(bit_counter) <= miso;
                        bit_counter <= bit_counter - 1;
                        if bit_counter < 0 then
                            data_out <= temp_data_in;  -- Actualizar salida con datos leídos
                            state <= deselect;
                        end if;
                    end if;

                when write_data =>
                    sck <= not sck;
                    if sck = '1' then
                        mosi <= temp_data_out(bit_counter);
                        bit_counter <= bit_counter - 1;
                        if bit_counter < 0 then
                            state <= deselect;
                        end if;
                    end if;

                when deselect =>
                    cs <= '1';  -- Deselect sensor
                    state <= idle;

            end case;
        end if;
    end process;
end Behavioral;